// Dependencies
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _d = require('./d');

var _d2 = _interopRequireDefault(_d);

// Public

var Path = (function () {
  function Path() {
    _classCallCheck(this, Path);

    this.lines = {};
  }

  _createClass(Path, [{
    key: 'draw',
    value: function draw() {
      var x = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
      var y = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

      // points to line
      var continualLine = this.lines[x - 1 + ',' + y];
      if (this.lines[x - 1 + ',' + y]) {
        continualLine.width++;
        this.lines[x + ',' + y] = continualLine;
      } else {
        this.lines[x + ',' + y] = new _d2['default'](x, y);
      }
    }
  }, {
    key: 'toElement',
    value: function toElement() {
      var d = '';
      var rendered = [];

      var rects = {};
      var history = {};
      for (var point in this.lines) {
        var line = this.lines[point];
        if (rendered.indexOf(line) > -1) {
          continue;
        }

        var x = line.x;
        var y = line.y;
        var width = line.width;

        var continualRect = history[x + ',' + (y - 1)];
        if (continualRect && continualRect.width == width) {
          continualRect.height++;
          history[x + ',' + y] = continualRect;
        } else {
          rects[x + ',' + y] = line;
          history[x + ',' + y] = line;
        }
        rendered.push(line);
      }

      for (var point in rects) {
        d += rects[point].toString();
      }
      return d;
    }
  }]);

  return Path;
})();

exports['default'] = Path;
module.exports = exports['default'];